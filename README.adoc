= ng-effects
:toc:
:toc-placement!:

Reactive local state management for Angular.

[source,typescript]
----
interface AppState {
    count: number
}

@Component({
    selector: "app-root",
    template: `
        <div>Count: {{count}}</div>
    `,
    providers: [HOST_EFFECTS],
})
export class AppComponent implements AppState {

    @Input()
    count: number = 0

    constructor(connect: Connect) {
        connect(this)
    }

    @Effect("count", { markDirty: true })
    incrementCount(state: State<AppState>) {
        return timer(1000).pipe(
            switchMapTo(state.count),
            take(1),
            increment(1),
            repeat()
        )
    }
}
----

toc::[]

== Installation

Install ng-effects via NPM

[source,bash]
----
npm install ng-effects
----

== Usage

=== Initialize effects

Effects are initialized through a `Connect` service. Inject `Connect` into your component or directive and call it from the constructor. `Connect` can only be injected when `HOST_EFFECTS` or `effects()` are provided.

[source,typescript]
----
@Component({
    providers: [HOST_EFFECTS]
})
export class AppComponent {
    count: number
    name: string

    constructor(connect: Connect) {
        this.count = 0
        connect(this) // Should always be called in the constructor
    }

    @Effect(options)
    someEffect() {
        // etc...
    }
}
----

=== Effect options

Effects can be configured through the decorator or factory function.

|===
|Option |Type |Description

|bind
|string
|When configured, maps values emitted by the effect to a property of the same name on the host context. This option is ignored if the effect does not return an observable.

|assign
|boolean
|When configured, assigns the properties of partial objects emitted by the effect to matching properties on the host context. This option is ignored if the effect does not return an observable.

|markDirty
|boolean
|When set to true, schedule change detection to run whenever a bound effect emits a value.

|detectChanges
|boolean
|When set to true, detect changes immediately whenever a bound effect emits a value.

|whenRendered
|boolean
|When set to true, the effect is not initialised until the host element has been mounted to the DOM.

|adapter
|Type<any>
|Hook into effects with a custom link:#_effect_adapters[effect adapter]. For example, to dispatch actions to a global store.
|===

==== Default options

Default behaviour can be configured in the `effect()` provider

[source,typescript]
----
@Component({
    providers: [
        effects([AppEffects], { markDirty: true })
    ]
})
export class AppComponent {}
----

=== Host effects

In simple cases, effects can be provided directly on the host. If no other effects need to be provided, you only have to pass in `HOST_EFFECTS` to the host provider.

[source,typescript]
----
@Component({
    providers: [HOST_EFFECTS]
})
export class AppComponent implements AppState {

    count: number

    constructor(connect: Connect) {
        this.count = 0
        connect(this)
    }

    @Effect()
    logCount(state: State<AppState>) {
        return state.count.subscribe(count => console.log(count))
    }
}
----

=== Effect services

Effects can be extracted into injectable services. These must be provided in the local `providers` (or `viewProviders`) array. Effects can be reused this way.

[source,typescript]
----
interface AppState {
    count: number
}

@Injectable()
export class AppEffects {
    @Effect("count")
    incrementCount(state: State<AppState>) {
        return timer(1000).pipe(
            switchMapTo(state.count),
            take(1),
            increment(1),
            repeat()
        )
    }
}

@Injectable()
export class OtherEffects {
    // etc...
}

@Component({
    selector: "app-root",
    template: `
        <div>Count: {{count}}</div>
    `,
    providers: [effects([AppEffects, OtherEffects])],
})
export class AppComponent implements AppState {

    count: number

    constructor(connect: Connect) {
        this.count = 0

        connect(this)
    }
}
----

== Examples

=== createEffect

Alternative syntax for effect declaration.

[source,typescript]
----
@Component()
export class AppComponent implements AppState {
    incrementCount = createEffect(
        (state: State<TestState>, context: Context<TestComponent>) =>
            timer(1000).pipe(
                switchMapTo(state.count),
                take(1),
                increment(1),
                repeat()
            ),
        { bind: "count", markDirty: true },
    )
}
----

=== Special injection tokens

Injected services share the same injector scope as their host. Special tokens such as `ElementRef` and `Renderer2` can be injected.

[source,typescript]
----
@Injectable()
export class AppEffects {
    constructor(private elementRef: ElementRef, private renderer: Renderer2) {}
}
----

==== HostRef

A reference to the host context can be injected using the `HostRef<T>` token.

[source,typescript]
----
@Injectable()
export class AppEffects {
    host: AppComponent
    state: State<AppComponent>
    observer: Observable<AppComponent>

    constructor(hostRef: HostRef<AppComponent>) {
        this.host = hostRef.instance
        this.state = hostRef.state
        this.observer = hostRef.observer
    }
}
----

The parent context can be injected using `SkipSelf()`

[source,typescript]
----
@Injectable()
export class ChildEffects {
    constructor(@SkipSelf() parent: HostRef<ParentComponent>) {}
}
----

===== instance

A reference to the component or directive instance.

===== state
A reference to the _observable state_ of the component or directive. Properties on this object are not populated unless they have been initialised in the host context constructor before calling `connect()`. Deferred properties such as view children are attached  after the component has rendered.

==== observer
Similar to `DoCheck`, except observable. Emits very frequently. Useful for custom change detection strategies or debugging.

=== Property bindings

Effects can be bound a named property on the host context by setting the `bind` property. This property is updated whenever the effect emits a new value. Throws an error if the property does not exist.

[source,typescript]
----
@Injectable()
export class AppEffects {
//  Alternatively:
//  @Effect({ bind: count, markDirty: true }
    @Effect("count", { markDirty: true })
    count(state: State<AppState>) {
        return timer(1000).pipe(
            switchMapTo(state.count),
            increment(1),
            take(1),
            repeat()
        )
    }
}
----

=== Multiple bindings

Multiple effects can be bound to the same property.

[source,typescript]
----
@Component()
export class AppComponent implements AppState {
    count: number

    @Effect("count", { markDirty: true })
    incrementCount(state: State<AppState>) {
        // implementation
    }

    @Effect("count", { markDirty: true })
    multiplyCount(state: State<AppState>) {
        // implementation
    }
}
----

=== Partial bindings

If the effect should update multiple properties on the host context at the same time, use the `assign` option.

[source,typescript]
----
@Component()
export class AppComponent implements AppState {
    @Effect({ assign: true })
    assignMany(state: State<AppState>) {
        return of({
            prop1: "value1",
            prop2: "value2"
        })
    }
}
----


=== Unsafe bindings

Effects with bindings are inferred from function arguments. Omitting these arguments will cause a type error. This error can be suppressed by passing `any` to the effect decorator.

[source,typescript]
----
@Injectable()
export class AppEffects {
    @Effect<any>("name")
    suppressTypeChecking() {
        // do unsafe binding
    }
}

----

=== Side effects

Effects that do not bind a property, or return a subscription/teardown function, are treated as side effects.

[source,typescript]
----
@Injectable()
export class AppEffects {
    @Effect()
    logCountWithObservable(state: State<AppState>) {
        return state.count.pipe(
            tap(count => console.log(count))
        )
    }

    @Effect()
    logCountWithSubscription(state: State<AppState>) {
        return state.count.subscribe(count => console.log(count))
    }

    @Effect()
    logCountWithTeardown(state: State<AppState>) {
        const sub = state.count.subscribe(count => console.log(count))
        return function () {
            sub.unsubscribe()
        }
    }
}
----

=== Output bindings

Effects can be easily connected to host outputs.

[source,typescript]
----
interface TestState {
    count: number
    countChange: HostEmitter<number>
}

@Injectable()
export class AppEffects {
    @Effect()
    countChange(state: State<TestState>) {
        return changes(state.count).subscribe(state.countChange)
    }
}
----

=== Template event bindings

Use an event emitter to ensure template events are properly propagated to trigger effects.

[source,typescript]
----
@Component({
    selector: "app-root",
    template: `<div (click)="clicked($event)">Click me<div>`,
    providers: [HOST_EFFECTS]
})
export class AppComponent {
    clicked = new HostEmitter<MouseEvent>()

    constructor(connect: Connect) {
        connect(this)
    }

    @Effect()
    handleTemplateClick(state: State<AppComponent>) {
        return state.clicked.subscribe(
            event => console.log(`click:`, event)
        )
    }
}
----

=== Host listener bindings

Use `HostEmitter` to bind `HostListener` properties. `HostEmitter` is a special subject that can also be invoked as a function. It's value is also unwrapped inside `State` so it can be used directly.

[source,typescript]
----
@Component({
    selector: "app-root",
    providers: [HOST_EFFECTS],
})
export class AppComponent {
    @HostListener("click", ["$event"])
    clicked: MouseEvent

    constructor(connect: Connect) {
        connect(this)
    }

    @Effect()
    handleClick(state: State<AppComponent>) {
        return state.clicked.subscribe((event) => {
            console.log("clicked", event)
        })
    }
}
----

=== Query bindings

All component queries (`ViewChild`, `ViewChildren`, `ContentChild`, `ContentChildren`) can be observed from `State`.

[source,typescript]
----
@Injectable()
export class ChildEffects {
    @Effect({ whenRendered: true })
    withContentChild(state: State<ChildComponent>) {
        return state.contentChild.subscribe(
            contentChild => console.log(contentChild)
        )
    }

    @Effect({ whenRendered: true })
    withContentChildren(state: State<ChildComponent>) {
        return state.contentChildren.subscribe(
            contentChildren => console.log(contentChildren)
        )
    }

    @Effect({ whenRendered: true })
    withViewChild(state: State<ChildComponent>) {
        return state.viewChild.subscribe(
            viewChild => console.log(viewChild)
        )
    }

    @Effect({ whenRendered: true })
    withViewChildren(state: State<ChildComponent>) {
        return state.viewChildren.subscribe(
            viewChildren => console.log(viewChildren)
        )
    }
}

@Component({
    selector: "app-child",
    template: `
        <app-child>Projected</app-child>
        <ng-content>Content</ng-content>
    `,
    providers: [effects(ChildEffects)],
})
export class ChildComponent {
    @ContentChild(ChildComponent)
    contentChild: ChildComponent

    @ContentChildren(ChildComponent)
    contentChildren: QueryList<ChildComponent>

    @ViewChild(ChildComponent)
    viewChild: ChildComponent

    @ViewChildren(ChildComponent)
    viewChildren: QueryList<ChildComponent>

    constructor(connect: Connect) {
        connect(this)
    }
}
----

=== DOM manipulation

Effects can be deferred until after the component has been rendered to the DOM tree. Combine with teardown logic to perform any DOM cleanup when the host is destroyed.

[source,typescript]
----
@Injectable()
export class AppEffects {
    constructor(private elementRef: ElementRef) {}

    @Effect({ whenRendered: true })
    mounted(state: State<AppComponent>, context: Context<AppComponent>) {
        const instance = thirdPartyLib.mount(this.elementRef.nativeElement)
        return function () {
            // cleanup logic
        }
    }
}
----

=== Compose multiple observable sources

Observable services can be injected, then composed. For example, compose http services when inputs change, or map global state to local state.

[source,typescript]
----
@Injectable()
export class AppEffects {
    constructor(private http: HttpClient, private store: Store<any>) {}

    @Effect("activeUser", { markDirty: true })
    selectActiveUser(state: State<AppComponent>) {
        return this.store.pipe(
            select(store => store.activeUser)
        )
    }

    @Effect()
    dispatchForm(state: State<AppComponent>, context: Context<AppComponent>) {
        return context.formData.valueChanges.subscribe(payload => {
            this.store.dispatch({
                type: "FORM_UPDATED",
                payload
            })
        })
    }

    @Effect()
    fetchUsers(state: State<AppComponent>) {
        return changes(state.userId).pipe(
            switchMap(userId => this.http.get<Users>(`https://example.com/users/${userId}`).pipe(
                catchError(error => {
                    console.error(error)
                    return NEVER
                })
            ))
        ).subscribe(state.usersFetched)
    }
}

@Component()
export class AppComponent {
    @Input() userId: string
    @Output() usersFetched: HostEmitter<Users>
    activeUser: User
    formData: FormGroup

    // etc...
}
----

=== Effect adapters

An effect adapter can be passed in to do additional processing after the observable has emitted a value. This can be useful for adding a dispatcher to automatically dispatch actions to a global state store.

[source,typescript]
----
interface Options {
    customOption: boolean
}

@Injectable({ providedIn: "root" })
export class Dispatch implements EffectHandler<Action, Options> {
    constructor(private store: Store<any>) {}

    next(action: Action, options: Options, metadata: EffectMetadata) {
        if (options.customOption) {
            this.store.dispatch(action)
        }
    }
}
----

[source,typescript]
----
@Injectable()
export class AppEffects {
    @Effect(Dispatch, { customOption: true })
    dispatchAction(state: State<AppComponent>, context: Context<AppComponent>) {
        return context.formData.valueChanges.pipe(
            map(payload => ({
                type: "FORM_UPDATED",
                payload
            }))
        )
    }
}
----

=== Bi-directional observable state

Through provider mapping observable state can be accessed from parent to child or vice versa.

[source,typescript]
----
@Component({
    providers: [{
        provide: ParentRef,
        useExisting: HostRef
    }, HOST_EFFECTS]
})
export class ParentComponent {
    @Input()
    selected?: ChildComponent = undefined

    @ViewChildren(ChildRef)
    children?: QueryList<ChildRef>

    constructor(connect: Connect) {
        connect(this)
    }

    @Effect("selected", { whenRendered: true })
    select(state: State<ParentComponent>) {
        return state.children.pipe(
            mergeAll(),
            mergeMap(child => child.state.select),
        )
    }
}

@Component({
    providers: [{
        provide: ChildRef,
        useExisting: HostRef
    }, HOST_EFFECTS],
})
export class ChildComponent {
    @Input()
    selected = false

    @Output()
    @HostListener("click", "this")
    select = new HostEmitter<ChildComponent>()

    constructor(private parentRef: ParentRef, connect: Connect) {
        connect(this)
    }

    @Effect("selected", { whenRendered: true })
    isSelected(state: State<ChildComponent>, context: Context<ChildComponent>) {
        return this.parentRef.state.selected.pipe(
            map(selected => selected === context)
        )
    }
}
----

== Experimental features

These features rely on unstable APIs that could break at any time.

=== Zoneless change detection

Zoneless change detection depends on experimental Ivy renderer features. To enable this feature, add the `USE_EXPERIMENTAL_RENDER_API` provider to your root module.

Zones can be disabled by commenting out or removing the following line in your app's `polyfills.ts`:

```
import "zone.js/dist/zone" // Remove this to disable zones
```

In your `main.ts` file, set ngZone to "noop".

```ts
platformBrowserDynamic()
    .bootstrapModule(AppModule, { ngZone: "noop" }) // set this option
    .catch(err => console.error(err))
```
